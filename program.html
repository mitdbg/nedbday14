
<!-- saved from url=(0046)http://db.csail.mit.edu/nedbday13/program.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <script type="text/javascript">

function toggle(element) {

  if (document.getElementById(element).style.display == "none") {

    document.getElementById(element).style.display = "";

  } else {

    document.getElementById(element).style.display = "none";

  }

}

</script> <title>New England Database Summit 2014 Program</title>
    <style type="text/css">
h2 {
padding-left: 0em;
      color : #0000CC;

}

title {
}

authors {
}

abstract {
}

BODY {
padding-left: 16em;
      background-color : #FFFFFF;
      font-family : Verdana, Geneva, Arial, Helvetica, sans-serif;
      color : #000088;
      margin: 0px; 
      width: 700px;
      }
  ul.navbar {
    position: absolute;
    top: 0em;
    left: 1em;
    width: 11em }

</style> </head>
  <body fgcolor="#000000" style="                background-color: white;">
    <table>
      <tbody>
        <tr>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>
            <h2> New England Database Summit 2014 Program <br>
            </h2>
            <!-- Site navigation menu -->
            <ul class="navbar">
			              <img src="newengland.jpg" width="200">
			              <li><a href="http://db.csail.mit.edu/nedbday14">Home page</a></li>
			              <li><a href="program.html">Program</a> </li>
			              <li><a href="papers.html">Accepted Papers</a> </li>
			              <li><a href="posters.html">Accepted Posters</a> </li>
				                 <li><a href="http://www.eventbrite.com/e/new-england-database-day-summit-tickets-9897331184">Registration</a>
			              <li><a href="https://cmt.research.microsoft.com/NEDB2014/">Submission Site</a>
			              </li>
			              <li><a href="http://whereis.mit.edu/map-jpg?selection=32">Map</a>
			              </li>
			            </ul>
			</ul>
            <center>
              <h2>Sponsors </h2>
              <p>Special thanks to this year's sponsors:<br>
                <br>
                <table border="0" cellspacing="0" width="100%">
                  <tbody>
                    <tr>
                      <td align="center"><img src="http://db.csail.mit.edu/nedbday13/logos/microsoft.jpg" width="180"></td>
                    </tr>
                  </tbody>
                </table>
              </p>
            </center>
            <h3> Friday, January 31, 2014
              <table frame="border">
                <tbody>
                  <tr>
                    <td width="150"> <u>Time</u> </td>
                    <td> <u>Event</u> </td>
                  </tr>
                  <tr>
                    <td> 9:00-9:10am<br>
                    </td>
                    <td> <strong>Welcome</strong> (Sam Madden and Tim Kraska)</td>
                  </tr>
					<tr>
                    <td> 9:10-9:20am<br>
                    </td>
                    <td> Sponsor Acknowledgements</td>
                  </tr>
                  <tr>
                    <td valign="top"> 9:20-10:10</td>
                    <td> <strong  >Keynote 1</strong>: Butler Lampson (Microsoft 
					Research).
                      <em>TBD</em> <a href="javascript:toggle(-2)">Click
                        to toggle abstract. </a>
                      <div id="-2" style="display: none;">
                        <p style="color: red; font-size: 70%;"> TBD
 </p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td> 10:10-10:30</td>
                    <td> Coffee Break</td>
                  </tr>
                  <tr>
                    <td>&nbsp;</td>
                  </tr>
                  <tr>
                    <th colspan="3" bgcolor="#8888FF"> Session 1: Visualization and Analytics (Chair: Tim Kraska)</th>
                  </tr>
                  <tr>
                    <td valign="top">10:30-10:50</td>
                    <td> Aditya Parameswaran (UIUC) <i>SeeDB: Visualizing Database Queries Efficiently</i> <a href="javascript:toggle(12)">Click
                        to show abstract. </a>
                      <div id="12" style="display: none;">
							<p style="color: blue; font-size: 70%;">Aditya Parameswaran, UIUC</p>
                        <p style="color: red; font-size: 70%;"> Data scientists rely on visualizations to interpret the data returned by queries, but finding the right visualization remains a manual task that is often laborious. We propose a DBMS that partially automates the task of finding the right visualizations for a query. In a nutshell, given an input query Q, the new DBMS optimizer will explore not only the space of physical plans for Q, but also the space of possible visualizations for the results of Q. The output will comprise a recommendation of potentially "interesting" or "useful" visualizations, where each visualization is coupled with a suitable query execution plan. In our talk, we will first discuss the technical challenges in building this system, and then present our current design as well as preliminary results.    The talk will be based on a vision paper, accepted to be presented at VLDB'14 (with N. Polyzotis and H. Garcia-Molina), as well as subsequent work with M. Vartak and S. Madden.  </p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">10:50-11:10</td>
                    <td>Alexander Kalinin (Brown University) <i> Interactive Data Exploration using Constraints </i>  <a href="javascript:toggle(26)">Click
                        to show abstract. </a>
                      <div id="26" style="display: none;">
							<p style="color: blue; font-size: 70%;">Alexander Kalinin*, Brown University; Ugur Cetintemel, Brown; Stan Zdonik, Brown</p>
                        <p style="color: red; font-size: 70%;">In this talk we present a vision of an interactive data exploration system, called SearchLight. The system is a fusion of Constraint Programming (CP) solvers and DBMSs. Data exploration is treated as a data-driven, online search problem and the CP solver is used to efficiently explore the constrained search space.    SearchLight allows users to explore large data sets by searching for objects of interest expressed through rich constraints. It seamlessly mediates a CP engine and a DBMS. SearchLight accelerates access to data by smart caching, prefetching and query optimization techniques, while making the solver cost-aware.    As a first step towards SearchLight, we present an exploration framework for multi-dimensional data called Semantic Windows (SW), in which users query for rectangular ``windows'' of interest via standard declarative SQL-style queries enhanced with exploration constructs. Users can specify SWs using (i) shape-based constraints, e.g., ``identify all 3-by-5 windows'' and (ii) content-based constraints, e.g., ``identify all windows in which the average brightness of stars exceeds 0.8''.    We argue that the SW approach enables the interactive processing of a host of useful exploratory queries that are difficult to express and optimize using standard DBMS techniques. To  demonstrate the utility and practicality of the constraint-based approach, we implemented  SW as a distributed layer on top of PostgreSQL and SciDB. We show experimental results with real-world and artificial data that reveal SW can offer online results quickly and continuously with little or no degradation in query completion times.</p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">11:10-11:30</td>
                    <td>Daniel Tahara (Yale University) <i>SQL Beyond Structure: Text, Documents and Key-Value Pairs </i> <a href="javascript:toggle(45)">Click
                        to show abstract. </a>
                      <div id="45" style="display: none;">
							<p style="color: blue; font-size: 70%;">Daniel Tahara*, Yale University; Daniel Abadi, Yale University</p>
                        <p style="color: red; font-size: 70%;">Despite, or perhaps because of, the bevy of data formats used in modern applications, the development community has yet to settle on a standard query interface for analyzing that data in an efficient manner. As a result, they are forced to rely on complicated scripting and ETL in order to analyze their data, significantly increasing their overall ‘time to insight.’    Meanwhile, SQL remains entrenched among the skillsets of analysts and database managers, with conventional wisdom saying that its semantics are incompatibile with the new, relaxed data formats. However, with our ‘Flexible Schema and Multi-structured Tables’ approach, we show that it is possible to unify structured, semi-structured, and fully un- structured data as part of a single analytics system. Our approach defines an extended relational abstraction (Multi- structured Tables) that maps arbitrarily structured data into a schema-ed, relational view (Flexible Schema). With these two components, we can then provide a storage backend in order to supply a performant, fully SQL-compliant analytics backend.</p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">11:30-11:50</td>
                    <td> Ashutosh Chauhan (Hortonworks)  <i>Major Technical Advancements in Apache Hive </i> <a href="javascript:toggle(20)">Click
                        to show abstract. </a>
                      <div id="20" style="display: none;">
							<p style="color: blue; font-size: 70%;">Yin Huai, The Ohio State Univeristy; Ashutosh Chauhan*, Hortonworks; Alan Gates, Hortonworks; Gunther Hagleitner, Hortonworks; Eric Hanson, Microsoft; Owen O’Malley, Hortonworks; Jitendra Pandey, Hortonworks; Yuan Yuan, The Ohio State University; Rubao Lee, The Ohio State University; Xiaodong Zhang, The Ohio State University</p>
                        <p style="color: red; font-size: 70%;">Apache Hive is a widely used data warehouse system for Apache Hadoop, and has been adopted by many organizations for various big data analytics applications. Closely working with many users and organizations, we have identified several shortcomings of Hive in its file formats, query planning, and query execution, which are key factors determining the performance of Hive. In order to make Hive continuously satisfy the requests and requirements of process- ing increasingly high volumes data in a scalable and efficient way, we have set two goals related to storage and runtime performance in our efforts on advancing Hive. First, we aim to maximize the effective storage capacity and to accelerate data accesses to the data warehouse by updating the existing file formats. Second we aim to significantly improve cluster resource utilization and runtime performance of Hive by developing a highly optimized query planner and a highly efficient query execution engine. In this paper, we present a community-based effort on technical advancements in Hive. Our performance evaluation shows that these advancements provide significant improvements on storage efficiency and query execution performance.</p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">11:50-12:10</td>
                    <td>Alekh Jindal (MIT)  <i>Graph Analytics on Relational Databases </i><a href="javascript:toggle(37)">Click to show
                        abstract. </a>
                      <div id="37" style="display: none;">
							<p style="color: blue; font-size: 70%;">Alekh Jindal*, MIT; Sam Madden, MIT; Amol Deshpande, ; Michael Stonebraker, MIT</p>
                        <p style="color: red; font-size: 70%;">Graph analytics is getting increasingly popular these days and there is a deluge of new systems for graph analytics. However, it is not clear how good or bad are the relational databases for graph analytics. In this talk, I will share our experiences with graph analytics on relational databases. Contrary to the popular belief, modern relational databases can have very good performance over graph analytics. Furthermore, we can offer better (and efficient) programming interfaces for expressing graph queries in relational databases, thereby not forcing the users to SQL.</p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td>&nbsp;</td>
                  </tr>
                  <tr>
                    <td> 12:00-01:10 </td>
                    <td> <strong>Lunch (Room 32-G449 Patil/Kiva)</strong> </td>
                  </tr>
                  <tr>
                    <td><br>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top"> 1:10-2:00</td>
                    <td> <strong>Keynote 2</strong>: James Mickens (Microsoft)
                      <i>TBD</i>  <a href="javascript:toggle(-1)">Click
                        to toggle abstract. </a>
                      <div id="-1" style="display: none;">
                        <p style="color: red; font-size: 70%;">tbd
</p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td>&nbsp;</td>
                  </tr>
                  <tr>
                    <th colspan="3" bgcolor="#8888FF"> Session 2: Apps / System Design (Chair: Aditya Parameswaran) </th>
                  </tr>
                  <tr>
                    <td valign="top">2:00-2:20</td>
                    <td>Alvin Cheung (MIT) <i> Using Lazy Evaluation for Query Batching </i><a href="javascript:toggle(23)">Click
                        to show abstract. </a>
                      <div id="23" style="display: none;">
							<p style="color: blue; font-size: 70%;">Alvin Cheung*, MIT CSAIL; Sam Madden, MIT; Armando Solar-Lezama, MIT CSAIL</p>
                        <p style="color: red; font-size: 70%;">Most web applications are backed by database servers that are phys- ically separated from the servers hosting the application. Even though the two machines typically reside in the same data cen- ter, a typical page load spends a significant amount of time issuing SQL queries and waiting for network roundtrips to complete, with a consequent impact on application latency. The situation is exacer- bated by object-relational mapping (ORM) frameworks such as Hi- bernate and Django, which provide the ability to access persistent database objects by manipulating native objects rather than issuing SQL queries. These frameworks automatically translate accesses to objects into SQL, often resulting in many database queries (and thus roundtrips) to reconstruct a single object. For example, even with two machines in the same data center, we found that many pages spend 50% or more of their time waiting for network round trips to complete.<br/>
						There are two general approaches to cope with this problem: i) programs can hide this latency by overlapping communication and computation, or ii) programs can reduce the number of roundtrips by fetching more data (or issuing multiple queries) in each one. Latency hiding is most commonly achieved by prefetching query results so that the communication time overlaps with computation, and the data is ready when the application really needs it. Both of these techniques have been explored in prior research. Latency hid- ing, which generally takes the form of asynchronously “prefetch- ing” query results so that they are available when needed by the program, was explored by Ramachandra et al. [2], where they em- ployed static analysis to identify queries that will be executed un- conditionally by a piece of code. The compiler can then transform the code so that these queries are issued as soon as their query pa- rameters are computed, and before their results are needed. Unfor- tunately, for many web applications there is not enough computa- tion to perform between the point when the query parameters are available and the query results are used, which reduces the effec- tiveness of the technique.<br/>
						On the other hand, many ORM frameworks employ some form of roundtrip reduction by allowing programmers to specify whether the fields of a persistent object should be fetched “lazily” (in a sep- arate roundtrip), or “eagerly” along with the parent object. The tradeoff here is additional network roundtrips (in the lazy approach) versus additional database accesses and network bandwidth for ob- jects that may never be accessed (in the eager approach). Unfortu- nately, it is very hard for programmers to mentally model the costs and tradeoffs of these two options, so these parameters tend to be set imprecisely and in an ad-hoc fashion.<br/>
						In this work, we describe a new approach for reducing the la- tency of database-backed applications that combines features of these two strategies. The goal is to reduce the number of roundtrips to the database by batching queries issued by the application us- ing extended lazy evaluation.1 As the application executes, queries are batched into a query store instead of being executed right away. Meanwhile, non-database related computation is delayed until it isabsolutely necessary. When a value that is derived from query re- sults is finally needed (say, when it is printed on the console), then all the queries that are batched in the query store are executed by the database in a single batch, and the results are then used to evaluate the outcome of the computation.<br/>
						Compared to query extraction using static analysis, our approach batches queries dynamically as the program executes, and defers computation as long as possible to maximize the opportunity to overlap query execution with program evaluation. As a result, it is able to batch queries across branches and even method calls, which results in larger batch sizes and fewer database roundtrips. Unlike the eager and lazy fetching strategies, our approach is not fundamentally tied to ORM frameworks. We have implemented this approach in a new system called Sloth. The system is targeted towards applications written in Java that use databases for persis- tent storage. Sloth consists of two components: a compiler and a number of libraries for runtime execution. Unlike traditional com- pilers, Sloth compiles the application source code to execute using extended lazy evaluation strategy. We discuss this compilation pro- cess using an example next.
</p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">2:20-2:40</td>
                    <td>Yanif Ahmad (Johns Hopkins University) <em>
					K3: Declarative Data Systems Programming</em><i>.
                      </i><a href="javascript:toggle(27)">Click to show
                        abstract. </a>
                      <div id="27" style="display: none;">
							<p style="color: blue; font-size: 70%;">Panchapakesan Shyamshankar, Johns Hopkins University; Yotam Barnoy, Johns Hopkins University; Yanif Ahmad*, Johns Hopkins University</p>
                        <p style="color: red; font-size: 70%;">We present K3, a software stack for building flexible distributed data management tools.  Motivated by the rapid uptake of data management and data analysis methods in numerous disciplines, K3's goals are to facilitate the simplified construction of domain-specific data systems and processing pipelines.  Its core contribution is a declarative abstraction layer that provides a separation of concerns between an algorithm's design in a general-purpose language, and its implementation and deployment as a distributed system.  In this talk, we present the ongoing design of two central features of our abstraction layer, declarative segmented data structures, and declarative execution strategies.  Our talk will focus on the abstraction layer design rather than on cost-based optimization techniques. </p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td> 2:40-3:00</td>
                    <td> Coffee Break</td>
                  </tr>
                  <tr>
                    <td><br>
                    </td>
                    <td><br>
                    </td>
                    <td><br>
                    </td>
                  </tr>
                  <tr>
                    <th colspan="3" bgcolor="#8888FF"> Session 3: Transactions / Streaming (Chair: Andy Pavlo) </th>
                  </tr>
                  <tr>
                    <td valign="top">3:00-3:20</td>
                    <td>Evan Jones (Mitro)
					<i>Trouble with Transactions (and other DB problems for small apps) </i><a href="javascript:toggle(43)">Click
                        to show abstract. </a>
                      <div id="43" style="display: none;">
						<p style="color: blue; font-size: 70%;">Evan Jones*, Mitro</p>
                        <p style="color: red; font-size: 70%;">Many things that database researchers consider “solved” are still problems for application developers in the "real world." As a former database researcher, I am personally guilty of working on problems that are interesting, without any experience actually building applications using databases. I've spent the last two years actually building applications that use databases, and I believe there is an opportunity for researchers and vendors to improve the state of the art by focusing on "usability" for application developers. In this talk, I’ll present my observations about what things actually cause developers pain, particularly for “small” apps that can comfortably fit on a single machine. This probably describes the vast majority of applications, and possibly even the majority of developer-hours, so these observations are (hopefully) widely applicable. </p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">3:20-3:40</td>
                    <td>Tobias Mühlbauer (Technische Universität München) <i>
                        HyPer: one DBMS for all </i><a href="javascript:toggle(48)">Click
                        to show abstract. </a>
                      <div id="48" style="display: none;">
						<p style="color: blue; font-size: 70%;">Tobias Mühlbauer*, Technische Universität München; Florian Funke, ; Viktor Leis, ; Henrik Mühe, ; Wolf Rödiger, ; Alfons Kemper, ; Thomas Neumann,</p>
                        <p style="color: red; font-size: 70%;">Ever increasing main memory capacities and processors with multiple cores have  fostered the development of database systems that process and store data solely  in main memory.    This talk presents HyPer, a high-performance hybrid  OLTP&OLAP main memory database system. Unlike other main memory database systems, HyPer aims at providing highest performance for both, OLTP AND OLAP workloads on brawny AND wimpy systems. OLAP query processing is separated from mission-critical OLTP  transaction processing using an efficient virtual memory (VM) snapshotting  mechanism. Platform-independent high-performance OLTP and OLAP is achieved by  efficiently compiling transactions and queries into efficient target machine code.  Even though the SQL-92 standard, a PL/SQL-like scripting language, and ACID-compliant  transactions are supported, HyPer has a memory footprint of just a few megabytes.  In particular, this talk highlights recent research efforts in the HyPer project, including (i) the adaptive radix tree (ART),  (ii) using Intel's recent hardware transactional memory (HTM) features for transaction processing, (iii) tentative execution of long-running transactions, (iv) compaction of memory-resident data, (v) efficient bulk loading of flat files at the wire speed of SSDs and 10 GbE adapters, (vi) the development of a locality-sensitive data-shuffling scheme, and (vii) a scaled-out version of the HyPer system that allows elastic OLAP throughput on transactional data.</p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td valign="top">3:40-4:00</td>
                     <td> Michael Stonebraker (MIT)<i> OLTP DBMSs are all Wrong</i> <a href="javascript:toggle(100)">Click
	                        to show abstract. </a>
	                      <div id="100" style="display: none;">
							<p style="color: blue; font-size: 70%;">Michael Stonebraker*, MIT</p>
	                        <p style="color: red; font-size: 70%;">The traditional wisdom for building OLTP DBMSs is to:    1) organize blocks of data on disk, with a main memory block cache.    2) implement an Aries-style write-ahead log.  3) use record level locking.  4) utilize a multi-threaded architecture.  5) Use an active-passive architecture for replication  6) use multi-threading    This traditional wisdom is exemplified in all the major DBMS products, including DB2, MySQL, Postgres, SQL Server, and Oracle.  In this talk we summarize the results of two recent papers and add new results on the efficiency of replication strategies.    Together these results present an essentially airtight case for:    1) a main memory DBMS  2) which archives cold tuples to secondary storage  3) active-active replication  4) operation (not data) logging  5) a lightweight concurrency control system that performs deterministic scheduling (OCC and MVCC are not deterministic)  6) either single threading or an architecture with few-to-none shared data structures    We conclude with the observation that essentially all OLTP DBMSs will need to be completely rewritten.      </p>
	                      </div>
	                    </td>
                  </tr>
                  <tr>
                    <td valign="top">4:00-4:20</td>
                    <td> Nesime Tatbul (Intel Labs) <i> S-Store: A Streaming OLTP System for Big Velocity Applications</i> <a href="javascript:toggle(110)">Click
                        to show abstract. </a>
                      <div id="110" style="display: none;">
						<p style="color: blue; font-size: 70%;"> Nesime Tatbul*, Intel Labs and MIT; Ugur Cetintemel, Brown; Tim Kraska, Brown; Sam Madden, MIT; John Meehan, Brown University; Andrew Pavlo, CMU; Michael Stonebraker, MIT; Hawk Wang, MIT; Stan Zdonik, Brown</p>
                        <p style="color: red; font-size: 70%;">In this talk, we will present S-Store - a new data management system for high-throughput low-latency transaction processing over large data sets that are frequently updated with high-speed data streams. The talk will cover the key ideas behind S-Store's architectural design, its ongoing prototype implementation as an extension to the H-Store main-memory OLTP system, and first experimental results comparing S-Store against H-Store. We will also discuss our ongoing efforts to address various research challenges that generally arise in a streaming OLTP system like S-Store.   </p>
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td>&nbsp;</td>
                  </tr>
                  <tr>
                    <td> 4:30 PM</td>
                    <td> <strong><a href="posters.html">Poster Session</a></strong>
                      and Appetizers / Drinks (Building 32, 8th Floor, 32-G882)</td>
                  </tr>
                  <tr>
                    <td> 6:30 PM</td>
                    <td> Adjourn </td>
                  </tr>
                </tbody>
              </table>
              <!-- Details coming soon!  A <a href="papers.php"> list of accepted papers </a> is available. -->
            </h3>
          </td>
        </tr>
      </tbody>
    </table>
  

</body></html>